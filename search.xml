<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python学习(二)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F08%2F02%2FPython%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Python常用函数 Python数据类型转换int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式, 并返回一个对象 eval(expression[, globals[, locals]]) expression: 表达式 globals - 变量作用域, 全局命名空间, 必须为字典对象 locals - 变量作用域, 局部命名空间, 可以是任何映射对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典, d必须是一个序列(key,value)元组 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 数学函数abs(x) 返回数字的绝对值，如abs(-10)返回10 ceil(x) 返回数字的上入整数， 如math.ceil(4.1)返回5 exp(x) 返回e的x次幂(ex), 如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值， 如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数， 如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0, math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数， 如math.log10(100)返回 2.0 max(x1, x2,...) 返回给定参数的最大值， 参数可以为序列。 min(x1, x2,...) 返回给定参数的最小值， 参数可以为序列。 modf(x) 返回x的整数部分与小数部分， 两部分的数值符号与x相同， 整数部分以浮点型表示。 pow(x, y) 返回x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值,如给出n值 则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根。 随机数函数使用随机函数时, 要导入random模块然后通过random静态对象调用该方法 choice(seq) 从序列的元素中随机挑选一个元素 比如random.choice(range(10))， 从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数， 基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内 seed([x]) 改变随机数生成器的种子seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内 Python 的字符串内建函数Python 的字符串常用内建函数如下： capitalize()将字符串的第一个字符转换为大写 center(width, fillchar)返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 count(str, beg= 0,end=len(string))返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 bytes.decode(encoding=”utf-8”, errors=”strict”)Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 encode(encoding=’UTF-8’,errors=’strict’)以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ endswith(suffix, beg=0, end=len(string))检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束如果是，返回 True,否则返回 False. expandtabs(tabsize=8)把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 find(str, beg=0 end=len(string))检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内如果包含返回开始的索引值，否则返回-1 index(str, beg=0, end=len(string))跟find()方法一样，只不过如果str不在字符串中会报一个异常. isalnum()如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False isalpha()如果字符串至少有一个字符并且所有字符都是字母则返回 True,否则返回 False isdigit()如果字符串只包含数字则返回 True 否则返回 False.. islower()如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False isnumeric()如果字符串中只包含数字字符，则返回 True，否则返回 False isspace()如果字符串中只包含空白，则返回 True，否则返回 False. istitle()如果字符串是标题化的(见 title())则返回True,否则返回False isupper()如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False join(seq)以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 len(string)返回字符串长度 ljust(width[, fillchar])返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower()转换字符串中所有大写字符为小写. lstrip()截掉字符串左边的空格或指定字符。 maketrans()创建字符映射的转换表，对于接受两个参数的最简单的调用方式第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str)返回字符串 str 中最大的字母。 min(str)回字符串 str 中最小的字母。 replace(old, new [, max])把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string))类似于 find()函数，不过是从右边开始查找. rindex( str, beg=0, end=len(string))类似于 index()，不过是从右边开始. rjust(width,[, fillchar])返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 rstrip()删除字符串字符串末尾的空格. split(str=””, num=string.count(str))num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 splitlines([keepends])按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 startswith(str, beg=0,end=len(string))检查字符串是否是以 obj 开头，是则返回 True，否则返回 False如果beg 和 end 指定值，则在指定范围内检查 strip([chars])在字符串上执行 lstrip()和 rstrip() swapcase()将字符串中大写转换为小写，小写转换为大写 title()返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) translate(table, deletechars=””)根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 deletechars 参数中 upper()转换字符串中的小写字母为大写 zfill (width)返回长度为 width 的字符串，原字符串右对齐，前面填充0 isdecimal()检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false]]></content>
      <categories>
        <category>后端/机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ基础学习(四)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F08%2F01%2FJQ%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[JQ动画 隐藏与显示hide()隐藏元素 $elem.hide() 提供参数： .hide( options ) 当提供hide方法一个参数时，.hide()就会成为一个动画方法.hide()方法将会匹配元素的宽度,高度,以及不透明度,同时进行动画操作 快捷参数： .hide(&quot;fast / slow&quot;) 这是一个动画设置的快捷方式,’fast’ 和 ‘slow’分别代表200和600毫秒的延时,就是元素会执行200/600毫秒的动画后再隐藏 注意：jQuery在做hide操作的时候，是会保存本身的元素的原始属性值,再之后通过对应的方法还原的时候还是初始值。 比如:一个元素的display属性值为inline，那么隐藏再显示时这个元素将再次显示inline。一旦透明度达到0，display样式属性将被设置为none这个元素将不再在页面中影响布局 show()方法的使用几乎与hide是一致的，hide是让元素显示到隐藏.show则是相反，让元素从隐藏到显示 注意事项： 1.show与hide方法是修改的display属性， 通过是visibility属性布局需要通过css方法单独设置 2.如果使用!important在你的样式中， 比如display: none !important，如果你希望.show()方法正常工作， 必须使用.css(‘display’, ‘block !important’)重写样式 3.如果让show与hide成为一个动画， 那么默认执行动画会改变元素的宽度，高度，透明度 toggle()元素显示与隐藏切换 基本的操作： toggle(); 这是最基本的操作,处理元素显示或者隐藏,因为不带参数,所以没有动画通过改变CSS的display属性,匹配的元素将被立即显示或隐藏,没有动画 1.如果元素是最初显示，它会被隐藏 2.如果隐藏的，它会显示出来 display属性将被储存并且需要的时候可以恢复。如果一个元素的display值为inline，然后是隐藏和显示，这个元素将再次显示inline 提供参数： .toggle( [duration ] [, complete ] ) 同样的提供了时间、还有动画结束的回调。在参数对应的时间内元素会发生显示/隐藏的改变在改变的过程中会把元素的高、宽、不透明度进行一系列动画效果。这个元素其实就是show与hide的方法 直接定位： .toggle(display) 直接提供一个参数，指定要改变的元素的最终效果其实就是确定是使用show还是hide方法 slideDown()下拉动画 .slideDown() 用滑动动画显示一个匹配元素 .slideDown()方法将给匹配元素的高度的动画，这会导致页面的下面部分滑下去，弥补了显示的方式 常见的操作，提供一个动画是时间，然后传递一个回调，用于知道动画是什么时候结束 .slideDown( [duration ] [, complete ] ) 持续时间(duration)是以毫秒为单位的,数值越大,动画越慢,不是越快。字符串’fast’和’slow’分别代表200和600毫秒的延时。如果提供任何其他字符串，或者这个duration参数被省略那么默认使用400 毫秒的延时。 注意事项： 1.下拉动画是从无到有，所以一开始元素是需要先隐藏起来的， 可以设置display:none 2.如果提供回调函数参数,callback会在动画完成的时候调用。将不同的动画串联在一起按顺序排列执行是非常有用的。这个回调函数不设置任何参数,但是 this会设成将要执行动画的那个DOM元素如果多个元素一起做动画效果,那么要非常注意,回调函数会在每一个元素执行完动画后都执行一次,而不是这组动画整体才执行一次 上卷与下拉slideUp()上卷动画 最简单的使用：不带参数 $(&quot;elem&quot;).slideUp(); 含义： 找到元素的高度，然后采用一个下滑动画让元素一直滑到隐藏，当高度为0的时候，也就是不可见的时，修改元素display样式属性被设置为none。这样就能确保这个元素不会影响页面布局了 带参数： .slideUp( [duration ] [, easing ] [, complete ] ) 同样可以提供一个时间，然后可以使用一种过渡使用哪种缓动函数，jQuery默认就2种，可以通过下载插件支持。最后一个动画结束的回调方法。 注意:因为动画是异步的所以要在动画之后执行某些操作就必须要写到回调函数里面 slideToggle()上卷下拉动画切换 基本的操作： slideToggle(); 这是最基本的操作，获取元素的高度，使这个元素的高度发生改变从而让元素里的内容往下或往上滑。 提供参数： .slideToggle( [duration ] ,[ complete ] ) 同样的提供了时间、还有动画结束的回调。在参数对应的时间内，元素会完成动画，然后出发回调函数 注意：1.display属性值保存在jQuery的数据缓存中，所以display可以方便以后可以恢复到其初始值 2.当一个隐藏动画后，高度值达到0的时候，display样式属性被设置为none，以确保该元素不再影响页面布局 淡入与淡出fadeOut()fadeOut()函数用于隐藏所有匹配的元素,并带有淡出的过渡动画效果所谓”淡出”隐藏的元素是隐藏状态不对作任何改变,元素是可见的,则将其隐藏。 .fadeOut( [duration ], [ complete ] ) 通过不透明度的变化来实现所有匹配元素的淡出效果，并在动画完成后可选地触发一个回调函数。这个动画只调整元素的不透明度，也就是说所有匹配的元素的高度和宽度不会发生变化。 fadeIn()淡入动画 方法使用与fadeout()是一致的，只是结果相反 .fadeIn( [duration ], [ complete ] ) duration：指定过渡动画运行多长时间(毫秒数)，默认值为400该参数也可以为字符串”fast”(=200)或”slow”(=600)元素显示完毕后需要执行的函数。函数内的this指向当前DOM元素 fadeIn()函数用于显示所有匹配的元素，并带有淡入的过渡动画效果 注意： 1.淡入的动画原理：操作元素的不透明度从0%逐渐增加到100% 2.如果元素本身是可见的,不对其作任何改变 如果元素是隐藏的,则使其可见 3.fadeIn：淡入效果，内容显示，opacity是0到1 fadeOut：淡出效果，内容隐藏，opacity是1到0 fadeToggle()淡入淡出切换adeToggle()函数用于切换所有匹配的元素并带有淡入/淡出的过渡动画效果 fadeToggle切换fadeOut与fadeIn效果 即:如果元素当前是可见的，则将其隐藏(淡出)如果元素当前是隐藏的，则使其显示(淡入) 常用语法： .fadeToggle( [duration ] ,[ complete ] ) 可选的duration参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒可选的 callback 参数是 fadeToggle完成后所执行的函数名称 fadeTo()淡入效果 语法: .fadeTo( duration, opacity ,callback) 必需的 duration参数规定效果的时长。它可以取以下值：”slow”、”fast” 或毫秒。fadeTo() 方法中必需的 opacity 参数将淡入淡出效果设置为给定的不透明度(值介于 0 与 1 之间)可选的 callback 参数是该函数完成后所执行的函数名称。 toggle与slideToggle以及fadeToggle的比较toggle与slideToggle细节区别： toggle：动态效果为从右至左。横向动作， toggle通过display来判断切换所有匹配元素的可见性 slideToggle： 动态效果从下至上。竖向动作， slideToggle 通过高度变化来切换所有匹配元素的可见性 fadeToggle方法: 1.fadeToggle()方法在fadeIn()和fadeOut()方法之间切换 2.元素是淡出显示的,fadeToggle()会使用淡入效果显示它们 3.元素是淡入显示的,fadeToggle()会使用淡出效果显示它们 4.注释：隐藏的元素不会被完全显示(不再影响页面的布局) 自定义动画animate()精确的控制样式属性从而执行动画 语法： .animate( properties ,[ duration ], [ easing ], [ complete ] ) .animate( properties, options ) 参数分解： 1.properties： (1)一个或多个css属性的键值对所构成的Object对象。要特别注意所有用于动画的属性必须是数字的，除非另有说明；这些属性如果不是数字的将不能使用基本的jQuery功能。比如常见的，border、margin、padding、width、heightfont、left、top、right、bottom、wordSpacing等等这些都是能产生动画效果的。 (2)如background-color是不可以,因为参数是red或者GBG这样的值除非用插件，否则正常情况下是不能只用动画效果的。注意，CSS 样式使用 DOM 名称（比如 “fontSize”）来设置,而非 CSS 名称(比如 “font-size”) (3)特别注意单位，属性值的单位像素（px）,除非另有说明。单位em 和 %需要指定使用 (4)除了定义数值，每个属性能使用’show’, ‘hide’, 和’toggle’这些快捷方式允许定制隐藏和显示动画用来控制元素的显示或隐藏 .animate({ width: &quot;toggle&quot; }); (5)如果提供一个以+= 或 -=开始的值,那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的 2.duration:设置动画执行的时间3.easing:规定要使用的 easing 函数，过渡使用哪种缓动函数4.step:规定每个动画的每一步完成之后要执行的函数5.progress:每一次动画调用的时候会执行这个回调,就是一个进度的概念6.complete:动画完成回调 注意:如果多个元素执行动画，回调将在每个匹配的元素上执行一次,不是作为整个动画执行一次 stop()当一个元素调用.stop()方法，当前正在运行的动画立即停止 语法： .stop( [clearQueue ], [ jumpToEnd ] ) .stop( [queue ], [ clearQueue ],[jumpToEnd]) stop还有几个可选的参数，简单来说可以这3种情况: (1).stop(); 停止当前动画，点击在暂停处继续开始 (2).stop(true);如果同一元素调用多个动画方法，尚未被执行的动画被放置在元素的效果队列中。这些动画不会开始，直到第一个完成。当调用.stop()的时候，队列中的下一个动画立即开始如果clearQueue参数提供true值,那么在队列中的动画其余被删除并永远不会运行 (3).stop(true,true); 当前动画将停止,但该元素上的 CSS 属性会被立刻修改成动画的目标值 inArray()查找数组中的索引,判断元素是否存在数组中 语法： jQuery.inArray( value, array ,[ fromIndex ] ) 传递一个检测的目标值，然后传递原始的数组可以通过fromIndex规定查找的起始值，默认数组是0开始 注意： 如果要判断数组中是否存在指定值，你需要通过该函数的返回值不等于(或大于)-1来进行判断 trim()jQuery.trim()函数用于去除字符串两端的空白字符 需要注意：移除字符串开始和结尾处的所有换行符,空格(包括连续的空格)和制表符（tab）如果这些空白字符在字符串中间时,它们将被保留,不会被移除 get()jQ是一个合集对象,如果需要单独操作合集中的的某一个元素可以通过.get()方法获取到. 语法： .get( [index ] ) 注意:1.get方法是获取的dom对象 也就是通过document.getElementById获取的对象 2.get方法是从0开始索引 负索引值参数:get方法还可以从后往前索引，传递一个负索引值注意的负值的索引起始值是-1 index()从匹配的元素中搜索给定元素的索引值，从0开始计数. 语法：参数接受一个jQuery或者dom对象作为查找的条件 .index() .index( selector ) .index( element ) 注意: 1.如果不传递任何参数给 .index() 方法，则返回值就是jQuery对象中第一个元素相对于它同辈元素的位置 2.如果在一组元素上调用 .index()并且参数是一个DOM元素或jQuery对象.index() 返回值就是传入的元素相对于原先集合的位置 3.如果参数是一个选择器，.index()返回值就是原先元素相对于选择器匹配元素的位置。如果找不到匹配的元素，则 .index() 返回 -1]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ基础学习(三)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F07%2F31%2FJQ%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[JQ事件 JQ鼠标事件click()与dbclick()监听用户的点击操作与监听用户的双击操作 $ele.click() 绑定$ele元素，不带任何参数一般是用来指定触发一个事件 $ele.click(handler(eventObject)) 绑定$ele元素,每次$ele元素触发点击操作会执行回调handler函数 $ele.click([eventData ], handler(eventObject)) 使用与方法二一致，不过可以接受一个数据参数， 这样的处理是为了解决不同作用域下数据传递的问题 dblclick()的用法和click()的用法是类似的 注意：在同一元素上同时绑定 click 和 dblclick 事件是不可取的。各个浏览器事件触发的顺序是不同的一些浏览器在dblclick之前接受两个 click 事件而一些浏览器只接受一个 click事件。用户往往可通过不同的操作系统和浏览器配置双击灵敏度 mousedown()与mouseup()监听用户鼠标按下的操作，与监听用户鼠标弹起的操作mousedown()与mouseup()和click()的用法是类似的 $ele.mousedown() $ele.mousedown(handler(eventObject)) $ele.mousedown([eventData], handler(eventObject)) mousedown事件触发需要以下几点： mousedown强调是按下触发 如果在一个元素按住了鼠标不放 并且拖动鼠标离开这个元素，并释放鼠标键 这仍然是算作mousedown事件 任何鼠标按钮被按下时都能触发mousedown事件 用event 对象的which区别按键 敲击鼠标左键which的值是1 敲击鼠标中键which的值是2 敲击鼠标右键which的值是3 mouseup事件： mouseup强调是松手触发 其他与mousedown一致 mousemove()监听用户移动的的操作mousemove()和click()的用法是类似的 $ele.mousemove() $ele.mousemove(handler(eventObject)) $ele.mousemove([eventData], handler(eventObject)) mousemove事件触发需要以下几点： 1.mousemove事件是当鼠标指针移动时触发的，即使是一个像素 2.如果处理器做任何重大的处理，或者如果该事件存在多个处理函数，这可能造成浏览器的严重的性能问题 mouseover()与mouseout()用于监听用户的移入移出操作mouseover()与mouseout()和click()的用法是类似的 $ele.mouseover() $ele.mouseover(handler(eventObject)) $ele.mouseover([eventData], handler(eventObject)) mouseenter与mouseleave事件监听用户移动到内部的操作三种参数传递方式与mouseover和mouseout是一模一样的 mouseenter事件和mouseover的区别: 1.mouseenter事件只会在绑定它的元素上被调用 而不会在后代节点上被触发 2.mouseover会产生事件冒泡 hover()用来给元素做一个简单的切换效果 $(selector).hover(handlerIn, handlerOut) 注:handlerIn(eventObject):当鼠标指针进入元素时触发执行的事件函数 handlerOut(eventObject):当鼠标指针离开元素时触发执行的事件函数 E.g.: $(&quot;p&quot;).hover( function() { $(this).css(&quot;background&quot;, &apos;red&apos;); }, function() { $(this).css(&quot;background&quot;, &apos;#bbffaa&apos;); } ); focusin()捕获用户点击聚焦的动作focusin()和click()的用法是类似的 $ele.focusin() $ele.focusin( handler ) $ele.focusin( [eventData ], handler ) focusout()捕获用户点击失焦的动作focusout()和click()的用法是类似的 $ele.focusout() $ele.focusout(handler) $ele.focusout( [eventData ], handler ) JQ表单事件blur()与focus()用于处理表单焦点blur()与focus()和focusin()与focusout()用法类似 区别:focus()在元素本身产生，focusin()在元素包含的元素中产生blur与focusout也亦是如此 change()元素,和元素的值都是可以发生改变的可以通过change事件去监听这些改变的动作 change()用法与click()用法类似 input元素: 监听value值的变化，当有改变时，失去焦点后触发change事件。 对于单选按钮和复选框，当用户用鼠标做出选择时，该事件立即触发 select元素: 对于下拉选择框，当用户用鼠标作出选择时，该事件立即触发 textarea元素: 多行文本输入框，当有改变时，失去焦点后触发change事件 select()当 textarea 或文本类型的 input 元素中的文本被选择时，会发生 select 事件。select()用法与click()用法类似 $ele.select() $ele.select(handler(eventObject)) $ele.select([eventData], handler(eventObject)) 注意: 这个函数会调用执行绑定到select事件的所有函数,包括浏览器的默认行为可以通过在某个绑定的函数中返回false来防止触发浏览器的默认行为 2.select事件只能用于元素与元素 submit()通过submit事件，监听提交表单的这个动作submit()用法与click()用法类似 $ele.submit() $ele.submit(handler(eventObject)) $ele.submit([eventData], handler(eventObject)) 具体能触发submit事件的行为： &lt;input type=&quot;submit&quot;&gt; &lt;input type=&quot;image&quot;&gt; &lt;button type=&quot;submit&quot;&gt; 当某些表单元素获取焦点时，敲击Enter(回车键) 特别注意：form元素是有默认提交表单的行为，如果通过submit处理的话，需要禁止浏览器的这个默认行为传统的方式是调用事件对象 e.preventDefault() 来处理jQuery中可以直接在函数中最后结尾return false即可 键盘事件keydown()与keyup()keydown事件:当用户在一个元素上第一次按下键盘上字母键的时候，就会触发用法与基本事件参数处理保持一致(与click()用法类似) $elem.keydown( handler(eventObject) ) $elem.keydown( [eventData ], handler(eventObject) ) $elem.keydown() keyup事件：当用户在一个元素上第一次松手键盘上的键的时候，就会触发它使用方法与keydown是一致的只是触发的条件是相反的 注意： keydown是在键盘按下就会触发 keyup是在键盘松手就会触发 理论上它可以绑定到任何元素 但keydown/keyup事件只是发送到具有焦点的元素上 不同的浏览器中，可获得焦点的元素略有不同 但是表单元素总是能获取焦点 所以对于此事件类型表单元素是最合适的 keydown事件触发在文字还没敲进文本框， 这时如果在keydown事件中输出文本框中的文本， 得到的是触发键盘事件前的文本 而keyup事件触发时整个键盘事件的操作已经完成 获得的是触发键盘事件后的文本 keypress()捕获键盘输入用法与keydown()非常相似 keypress事件与keydown和keyup的主要区别: 1.只能捕获单个字符，不能捕获组合键2.无法响应系统功能键（如delete，backspace）3.不区分小键盘和主键盘的数字字符 KeyPress主要用来接收字母、数字等ANSI字符，而KeyDown和KeyUP事件过程可以处理任何不被KeyPress识别的击键 诸如：功能键（F1-F12）、编辑键、定位键 以及任何这些键和键盘换档键的组合等 事件的绑定与解绑on()用于给元素绑定事件 基本用法： .on( events ,[ selector ] ,[ data ] ) 多个事件绑定同一个函数 $(&quot;#elem&quot;).on(&quot;mouseover mouseout&quot;,function(){ }); 多个事件绑定不同函数 $(&quot;#elem&quot;).on({ mouseover:function(){}, mouseout:function(){} }); 将数据传递到处理程序: function greet( event ) { alert( &quot;Hello &quot; + event.data.name ); } $( &quot;button&quot; ).on( &quot;click&quot;, { name: &quot;World&quot; }, greet ); on()的高级用法委托机制: .on( events ,[ selector ] ,[ data ], handler(eventObject) ) E.g: &lt;div class=&quot;left&quot;&gt; &lt;p class=&quot;aaron&quot;&gt; &lt;a&gt;目标节点&lt;/a&gt; //点击在这个元素上 &lt;/p&gt; &lt;/div&gt; 给出如下代码： $(&quot;div&quot;).on(&quot;click&quot;,&quot;p&quot;,fn) 事件绑定在最上层div元素上，当用户触发在a元素上 事件将往上冒泡，一直会冒泡在div元素上。如果提供了第二参数 那么事件在往上冒泡的过程中遇到了选择器匹配的元素， 将会触发事件回调函数 off()方法通过.on()绑定的事件处理程序,可以通过off() 方法移除该绑定 根据on绑定事件的一些特性,off方法也可以通过相应的传递组合的事件名,名字空间,选择器或处理函数来移除绑定在元素上指定的事件处理函数当有多个过滤参数时,只有与这些参数完全匹配的事件处理函数才会被移除 E.g.: 绑定2个事件: $(&quot;elem&quot;).on(&quot;mousedown mouseup&quot;,fn) 删除一个事件: $(&quot;elem&quot;).off(&quot;mousedown&quot;) 删除所有事件: $(&quot;elem&quot;).off(&quot;mousedown mouseup&quot;) $(&quot;elem&quot;).off() 事件对象的使用事件对象的作用jQuery事件回调方法中获取到的事件对象是经过兼容后处理过的一个标准的跨浏览器对象 事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问在所有事件处理函数运行结束后，事件对象就被销毁 event.target target 属性可以是注册事件时的元素，或者它的子元素通常用于比较event.target和this来确定事件是不是由于冒泡而触发的也常用于事件冒泡时处理事件委托 简单来说：event.target代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素 对象的属性和方法event.type 获取事件的类型 event.pageX和event.pageY 获取鼠标当前相对于页面的坐标 event.preventDefault() 阻止默认行为 event.stopPropagation() 阻止事件冒泡 event.which 获取在鼠标单击时,单击的是鼠标的哪个键 event.currentTarget 在事件冒泡过程中的当前DOM元素 this和event.target的区别： js中事件是会冒泡的，所以this是可以变化的但event.target不会变化，它永远是直接接受事件的目标DOM元素; .this和event.target都是dom对象如果要使用jquey中的方法可以将他们转换为jquery对象 自定义事件trigger事件原生事件: 由浏览器提供的叫原生事件这类事件是需要有交互行为才能被触发 自定义事件trigger: 根据绑定到匹配元素的给定的事件类型执行所有的处理程序和行为 trigger除了能够触发浏览器事件，同时还支持自定义事件，并且自定义时间还支持传递参数 E.g.: $(&apos;#elem&apos;).on(&apos;Aaron&apos;, function(event,arg1,arg2){ alert(&quot;自触自定义时间&quot;) }); $(&apos;#elem&apos;).trigger(&apos;Aaron&apos;,[&apos;参数1&apos;,&apos;参数2&apos;]) trigger触发浏览器事件与自定义事件区别: 1.自定义事件对象，是jQuery模拟原生实现的2.自定义事件可以传递参数 trigger事件还有一个特性：会在DOM树上冒泡所以如果要阻止冒泡就需要在事件处理程序中返回false或调用事件对象中的.stopPropagation() 方法可以使事件停止冒泡 trigger事件是具有触发原生与自定义能力的，但是存在一个不可避免的问题： 事件对象event无法完美的实现 triggerHandler事件triggerHandler与trigger的用法是一样的，重点看不同之处： 1.triggerHandler不会触发浏览器的默认行为， .triggerHandler( &quot;submit&quot; )将不会调用表单上的.submit() 2..trigger() 会影响所有与jQuery对象相匹配的元素, 而 .triggerHandler()仅影响第一个匹配到的元素 3.使用.triggerHandler()触发的事件,并不会在DOM树中向上冒泡 如果它们不是由目标元素直接触发的,那么它就不会进行任何处理 4.与普通的方法返回 jQuery 对象(这样就能够使用链式用法) 相反，.triggerHandler() 返回最后一个处理的事件的返回值 如果没有触发任何事件，会返回 undefined]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ基础学习(二)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F07%2F31%2FJQ%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[JQ DOM DOM的创建创建元素节点$(&quot;&lt;div&gt;&lt;/div&gt;&quot;) 创建文本节点$(&quot;&lt;div&gt;我是文本&lt;/div&gt;&quot;) 创建为属性节点$(&quot;&lt;div id=&apos;test&apos; class=&apos;arron&apos;&gt;我是文本&lt;/div&gt;&quot;) DOM节点的插入内部插入.append(content) 向每个匹配的元素内部追加内容 .appendTo(content) 把所有匹配的元素追加到 另一个指定的元素集合中 .prepend(content) 向每个匹配的元素内部前置内容 .prependTo(content) 把所有匹配的元素前置到另一个 指定的元素集合中 外部插入.after(content) 在匹配元素集合中的每个元素后面 插入参数所指定的内容,作为其兄弟节点 .before(content) 据参数设定,在匹配的元素前面 插入内容 支持多参数传递 .insertBefore(content) 在目标元素前插入集合中 每个匹配的元素 .insertAfter(content) 在目标元素后面插入集合中 每个匹配的元素 DOM节点的删除.empty() 清空了匹配元素下所有子元素 .remove() 删除自身 remove()可以传递一个选择器表达式用来过滤将被移除的匹配元素集合可以选择性的删除指定的节点 .detch() 删除自身 detch()不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是,所有绑定的事件、附加的数据等都会保留下来 $(“div”).detach()这一句会移除对象,仅仅是显示效果没有了但是内存中还是存在的当你append之后，又重新回到了文档流中。就又显示出来了 .unwrap() 将匹配元素集合的父级元素删除, 保留自身(和兄弟元素)在原来位置 DOM的复制与替换拷贝clone()clone()方法深度 复制所有匹配的元素集合，包括所有匹配元素、匹配元素的下级元素、文字节点。 .clone() 只克隆了结构，事件丢失 .clone(true) 结构、事件与数据都克隆 注意: 1.clone()方法时，在将它插入到文档之前 我们可以修改克隆后的元素或者元素内容如: $(this).clone().css(‘color’,’red’) 增加了一个颜色 2.通过传递true 将所有绑定在原始元素上的事件处理函数复制到克隆元素上 3.clone()方法是jQuery扩展的， 只能处理通过jQuery绑定的事件与数据 4.元素数据（data）内对象和数组不会被复制 将继续被克隆元素和原始元素共享深复制的所有数据 需要手动复制每一个 替换replaceWith()和replaceAll().replaceWith(newContent) 用提供的内容替换集合中所有匹配的元素 并且返回被删除元素的集合 .replaceAll(target) 用集合的匹配元素替换每个目标元素 .replaceWith()与replaceAll()会删除与节点相关联的所有数据和事件处理程序 包裹wrap().wrap(wrappingElement) 在集合中匹配的每个元素周围包裹一个HTML结构 .wrap(function) 一个回调函数,返回用于包裹匹配元素的HTML内容或jQuery对象 全包裹wrapAll().wrapAll(wrappingElement) 给集合中匹配的元素增加一个外面包裹HTML结构 .wrapAll(function) 一个回调函数,返回用于包裹匹配元素的HTML内容或jQuery对象 内部包裹wrapInner().wrapInner(wrappingElement) 给集合中匹配的元素的内部,增加包裹的HTML结构 .wrapInner(function) 允许我们用一个callback函数做参数 每次遇到匹配元素时,该函数被执行,返回一个DOM元素, jQuery对象,或者HTML片段，用来包住匹配元素的内容 JQ遍历children().children(selector) 返回匹配元素集合中每个元素的所有子元素 注意：1.jQuery是一个合集对象， 所以通过children是匹配合集中每一给元素的第一级子元素 2.children()方法选择性地接受同一类型选择器表达式 find().find() 查找匹配元素的后代元素 注意: 1.find是遍历当前元素集合中每个元素的后代。 只要符合，不管是儿子辈，孙子辈都可以。 2.与其他的树遍历方法不同,选择器表达式对于.find() 是必需的参数。如果我们需要实现对所有后代元素的取回， 可以传递通配选择器 * 3.find只在后代中遍历，不包括自己 选择器context是由.find()方法实现的; 因此, $(‘.item-ii’).find(‘li’) 等价于$(‘li’, ‘.item-ii’) (找到类名为item-ii的标签下的li标签) parent().parent() 返回匹配元素集合中每一个元素的父元素 注意:1.JQuery是一个合集对象，所以通过parent是匹配合集中每一个元素的父元素 2.parent()方法选择性地接受同一型选择器表达式 parents().parents() 查找合集里面的每一个元素的所有祖辈元素 注意: 1.jQuery是一个合集对象， 所以通过parent是匹配合集中所有元素的祖辈元素2.parents()方法选择性地接受同一型选择器表达式 3.parents()和.parent()方法是相似的， 但后者只是进行了一个单级的DOM树查找 4.$( “html” ).parent()方法返回一个包含document的集合 而$( “html” ).parents()返回一个空集合 closest()closest() 从元素本身开始在DOM上逐级向上级元素匹配 并返回最先匹配的祖先元素 注意:1.closest()方法接受一个匹配元素的选择器字符串2.jQuery是一个合集对象 所以通过closest是匹配合集中每一个元素的祖先元素3.closest()方法给定的jQuery集合或元素来过滤元素 closest与parents()区别1.起始位置不同：.closest开始于当前元素 .parents开始于父元素 2.遍历的目标不同：.closest要找到指定的目标，.parents遍历到文档根元素，closest向上查找，直到找到一个匹配的就停止查找，parents一直查找到根元素，并将匹配的元素加入集合 3.结果不同：.closest返回的是包含零个或一个元素的jquery对象，parents返回的是包含零个或一个或多个元素的jquery对象 next().next() 返回元素集合中每一个元素 紧邻的后面同辈元素的元素集合 注意: 1.jQuery是一个合集对象， 所以通过next匹配合集中每一个元素的下一个兄弟元素 2.next()方法选择性地接受同一类型选择器表达式 prev().prev() 查找指定元素集合中 每一个元素紧邻的前面同辈元素的元素集合 注意:1.jQuery是一个合集对象 所以通过prev是匹配合集中每一个元素的上一个兄弟元素2.prev()方法选择性地接受同一类型选择器表达式 siblings().siblings() 查找指定元素集合中每一个元素的同辈元素 注意: 1.JQuery是一个合集对象 所以通过siblings是匹配合集中每一个元素的同辈元素2.siblings()方法选择性地接受同一类型选择器表达式 增添add().add() 用来创建一个新的jQuery对象 元素添加到匹配的元素集合中 注:.add()的参数可以几乎接受任何的$()包括一个jQuery选择器表达式，DOM元素，或HTML片段引用 遍历each()each()就是一个for循环的迭代器它会迭代jQuery对象合集中的每一个DOM元素每次回调函数执行时,会传递当前循环次数作为参数(从0开始计数) .each() 遍历指定元素集合中的每个元素 jQuery.each(array, callback ) jQuery.each(object, callback ) 第一个参数传递的就是一个对象或者数组，第二个是回调函数 注: 1.each回调方法中的this指向当前迭代的dom元素 2.如果需要提前退出,可以通过返回false 以便在回调函数内中止循环. 如果返回其他任何值，均表示继续执行下一个循环。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习(一)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F04%2F22%2FPython%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Python基础语法与数据类型 python基本语法注释# 单行注释 &quot;&quot;&quot;&quot;&quot;&quot; 或 &apos;&apos;&apos;&apos;&apos;&apos; 多行注释 逻辑运算and x and y (同&amp;&amp;) or x or y (同||) not not x (同!) 成员运算in x in y not in x not in y 身份运算is 判断两个标识符是不是引用自同一个对象 not is 与 is 相反 id() 用于获取对象的内存地址 注: == 判断引用变量的值是否相等 语法知识1.python可以在同一行中使用多条语句,语句间用分号(;)分割2.print默认输出是换行的, 如果要是实现不换行要在变量末尾 加上 end=””3.python可以用斜杠()将一行的语句分成多行,在[], {}, 或()中的多行语句，不需要使用反斜杠() import与from…import导入相应的模块 语法: import somemodule 将整个模块(somemodule)导入 from somemodule import somefunction 从某个模块中 导入某个函数 from somemodule import firstfunc, 从某个模块中 secondfunc, thirdfunc 导入多个函数 from somemodule import * 将某个模块中的全部函数导入 基本数据类型不可变: Number(数字), String(字符串), Tuple(元组) 可变: List(集合), Dictionary(字典), Sets(集合) type()函数可以查询变量所指的对象类型 Number声明: int, float, bool, complex(复数)Python3中, 只有一个整数类型, 表示为长整型 isinstance()函数用来判断变量类型 isinstance(var, class) 函数用来判断变量类型 是返回True, 否返回False type()与isinstance()区别: 1.type()不会认为子类是一种父类类型 2.isinstance()则会 del语句用于删除一些对象引用 语法: del var1[, var2[, var3[..., varN]]] 数值运算:符号与用法和C语言基本一致(只列出不同的) a/b # 除法, 得到一个浮点数 a//b # 除法, 得到一个整数 a**b # 乘方, a^b 基本知识 1.一个变量可以通过赋值指向不同类型的对象 2.混合计算时, Python会把整型转换成浮点型 3.复数, 用a+bj或complex(a,b)表示, 复数的实虚部都是浮点型 StringPython中的字符串用单引号 ‘ 或双引号 “ 括起来，同时使用反斜杠 \ 转义特殊字符。 字符串的截取的语法格式如下： 变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。加号 + 是字符串的连接符,星号 * 表示复制当前字符串，紧跟的数字为复制的次数 E.g.: print (str) # 输出字符串 print (str[0:-1]) # 输出第一个到倒数第二个的所有字符 print (str[0]) # 输出字符串第一个字符 print (str[2:5]) # 输出从第三个开始到第五个的字符 print (str[2:]) # 输出从第三个开始的后的所有字符 print (str * 2) # 输出字符串两次 print (str + &quot;TEST&quot;) # 连接字符串 Python 使用反斜杠()转义特殊字符，如果你不想让反斜杠发生转义，可以在字符串前面添加一个 r表示原始字符串 E.g. print(r&quot;\nPython&quot;) 输出: \nPython 反斜杠()也可以作为续行符，表示下一行是上一行的延续。也可以使用 “””…””” 或者 ‘’’…’’’ 跨越多行 注意： 1.反斜杠可以用来转义，使用r可以让反斜杠不发生转义。2.字符串可以用+运算符连接在一起，用 * 运算符重复。3.Python中的字符串有两种索引方式,从左往右以0开始,从右往左以-1开始4.Python中的字符串不能改变。5.Python中没有单独的字符类型，一个字符就是长度为1的字符串 Set1.集合是一个无序不重复元素的序列2.主要用于进行成员关系测试和删除重复元素3.可用大括号{}或set()函数创建集合 注意,创建一个空集合必须使用set(),空的{} 用于创建空字典 e.g: parame = {value1, value2, ….} 或 set(value) 4.输出集合是,重复的元素会被自动去掉 成员测试 if &apos;xx&apos; in parame : print(&apos;&apos;) else: print(&apos;&apos;) set可以进行集合运算 a = set(&apos;abracadabra&apos;) b = set(&apos;alacazam&apos;) a - b # a和b的差集 a | b # a和b的并集 a &amp; b # a和b的交集 a ^ b # a和b中不同时存在的元素 注意: - 不等于 ^ List1.List写在方括号[]内, 元素用逗号隔开, eg: List = [1, 2, 3,…] 2.List中的元素类型可以不同, 它支持数字, 字符串, 列表(嵌套) 3.和字符串类似, List也可以截取, 索引值与字符串相同 变量[头下标:尾下标], (+)拼接, ( * )重复输出 4.List中的元素可以被修改 Tuple1.与List相似, 元素类型可以不同, 不过元素不可以被修改 但可以包含可被修改的元素 2.元组写在()小括号内, 元素间用逗号隔开 3.字符串可以看作是一个特殊的元组, 方法相同 4.特殊的构造语法: tuple1 = () # 空元组 tuple2 = (20,) # 一个元素的元组, 需在元素后添加逗号 String, List和Tuple都属于sequence(序列) Dictionary1.字典是无序的对象集合, 列表是有序的对象集合,二者区别: 字典元素是通过健来存取,而不是通过偏移存取 2.字典是一种映射类型, 字典用{}标识,它是一个无序的键(key):值(value)对集合 3.键(key)必须使用不可变类型4.同一字典中, 键(key)必须是唯一的 E.g.: dict = {} dict[&apos;one&apos;] = &quot;Python&quot; dict[2] = &quot;C&quot; print (dict[&apos;one&apos;]) # 输出键为 &apos;one&apos; 的值 print (dict[2]) # 输出键为 2 的值 print (dict) # 输出完整的字典 print (dict.keys()) # 输出所有键 print (dict.values()) # 输出所有值 5.构造函数 dict() 可以直接从键值对序列中构建字典如下：E.g. dict([(&apos;Runoob&apos;, 1), (&apos;Google&apos;, 2), (&apos;Taobao&apos;, 3)]) =&gt;{&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2} {x: x**2 for x in (2, 4, 6)} =&gt;{2: 4, 4: 16, 6: 36} dict(Runoob=1, Google=2, Taobao=3) =&gt;{&apos;Taobao&apos;: 3, &apos;Runoob&apos;: 1, &apos;Google&apos;: 2} 6.创建空字典使用 { } 7.遍历字典 for key, value in obj.items(): 8.去掉重复值 set(obj.values()) 拓展1.当函数返回多个值时, 是以元组方式返回的 2.字典是使用了散列表(hashtable)算法 3.如果一个字典对象作为for的迭代对象, 那么这个操作 将会遍历字典所有的键 4.isinstance主要用于判断A类是否继承与B类 5.为什么python没有自增, 自减运算符? python中一个变量可以以多个名称访问, 即以内容为基准, 不像C中已变量为基准, 所以python中数字类型的值不可改变. eg: a=5, b=5, a, b具有相同的地址, 当 a 改变时 b也改变了, 所以只能以 a += 1 或 a = a+1 来 改变a的值, 执行后,a的地址也改变了 注: 在交互环境中(编译器)会有一个小整池的概念, 它会把(-5, 256)间的数先预先创建好,当a与b超过 这个范围时, 两个变量就会指向不同的对象, 因此地址也会不一样. 6.” _ “下划线,表示上一次的输出结果, 应视其为有只读变量 7.Python不支持复数转换成整数或浮点数 8.round()函数,规则为: “4舍6入5看齐, 奇进偶不进” 9.Python3 中 cmp()函数的代替函数:返回ture或false import operator # 需先引入运算符模块 operator.gt(x, y) # greater than(x&gt;y?) operator.ge(x, y) # greater and equal(x&gt;=y?) operator.eq(x, y) # equal (x=y?) operator.le(x, y) # less and equal (x&lt;=y?) operator.lt(x, y) # less than (x&lt;y?) 10.fractions模块提供了分数类的支持 可以同时提供分子(numerator)和分母(denominator) 给构造函数用于实例化Fraction类, 但两者必须同时是int类型 或numbers.Rational类型,否则会抛出类型错误.当分母为0, 初始化的时候回导致抛出异常ZeroDivisionError 11.Python字符串格式化字符串格式化使用与C中sprintf函数一样的语法eg: print(“hello,%s” %(‘Python’))%c 格式化字符串及其ASCII码,其他与C一致 12.Python三引号允许一个字符串跨多行, 字符串可以包括 换行符, 制表符以及其他特殊字符 13.Python中,所有字符都是Unicode字符串, 普通字符串是以ASCII码进行存储的,而Unicode 字符串则储存为16位unicode字符串]]></content>
      <categories>
        <category>后端/机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQ基础学习(一)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F04%2F22%2FJQ%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JQ样式 JQ基础知识$(document).ready 的作用是等页面的文档（document）中的节点都加载完毕后，再执行后续的代码 通过jQuery方法包装后的对象，是一个类数组对象。它与DOM对象完全不同，唯一相似的是它们都能操作DOM。 JQ对象转换为DOM对象1.利用数组下标的方式读取到jQuery中的DOM对象 var $div = $(&apos;div&apos;) //jQuery对象 var div = $div[0] //转化成DOM对象 2.通过jQuery自带的get()方法jQuery对象自身提供一个.get() 方法允许我们直接访问jQuery对象中相关的DOM节点 var $div = $(&apos;div&apos;) //jQuery对象 var div = $div.get(0) //通过get方法,转化成DOM对象 DOM对象转换为JQ对象如果传递给$(DOM)函数的参数是一个DOM对象，jQuery方法会把这个DOM对象给包装成一个新的jQuery对象 var div = document.getElementsByTagName(&apos;div&apos;); //dom对象 var $div = $(div); //jQuery对象 JQ选择器id选择器通过元素的id名获取节点 $( &quot;#id&quot; ) 类选择器通过class样式类名来获取节点 $( &quot;.class&quot; ) 元素选择器根据给定（html）标记名称选择所有的元素 $( &quot;element&quot; ) 全选择器通过传递 ‘星号’ 选择器来选中文档页面中的元素 $( &quot;*&quot; ) 层级选择器子选择器选择所有指定”parent”元素中指定的”child”的直接子元素 $(&quot;parent&gt;child&quot;) 后代选择器选择给定的”ancestor”元素的所有后代元素 $(&quot;ancestor descendant&quot;) 相邻兄弟选择器选择所有紧接在”prev”元素后的”next”元素 $(&quot;prev+next&quot;) 一般兄弟选择器匹配”prev”元素之后的所有兄弟元素,具有相同的父元素并匹配过滤”siblings”选择器 $(&quot;prev~siblings&quot;) 基本筛选选择器$(&quot;:first&quot;) 匹配第一个元素 $(&quot;:last&quot;) 匹配最后一个元素 $(&quot;:not(seletor)&quot;) 选择所有元素除去不匹配给定 的选择器元素 $(&quot;:eq(index)&quot;) 在匹配的集合中选择索引为index的元素 $(&quot;:gt(index)&quot;) 在匹配的集合中选择索引大于index的元素 $(&quot;:lt(index)&quot;) 在匹配的集合中选择索引小于index的元素 $(&quot;:even&quot;) 选择索引值为偶数的元素,从零开始计数 $(&quot;:odd&quot;) 选择索引值为奇数的元素,从零开始计数 $(&quot;:header&quot;) 选择所有标题元素,e.g.:h1,h2... $(&quot;:lang(language)&quot;) 选择指定语言的所有元素 $(&quot;:root&quot;) 选择该文档的根元素 $(&quot;:animated&quot;) 选择所有正在执行动画效果的元素 注意事项： 1.:eq(), :lt(), :gt(), :even, :odd用来筛选他们前面的匹配表达式的集合元素，根据之前匹配的元素在进一步筛选注意jQuery合集都是从0开始索引 2.gt是一个段落筛选，从指定索引的下一个开始，gt(1) 实际从2开始 内容筛选选择器$(&quot;:contains(text)&quot;) 选择所有包含指定文本的元素 $(&quot;:parent&quot;) 选择所有含有子元素或者文本的元素 $(&quot;:empty&quot;) 选择所有没有子元素的元素(包括文本) $(&quot;:has(selector)&quot;) 选择元素中至少包含指定选择器的元素 注意事项： 1.:contains与:has都有查找的意思，但是contains查找包含“指定文本”的元素，has查找包含“指定元素”的元素 2.如果:contains匹配的文本包含在元素的子元素中，同样认为是符合条件的。:parent与:empty是相反的，两者所涉及的子元素，包括文本节点 可见性筛选选择器$(&quot;:visible&quot;) 选择所有显示的元素 $(&quot;:hidden&quot;) 选择所有隐藏的元素 Note: 1.:hidden选择器，不仅仅包含样式是display=”none”的元素，还包括隐藏表单、visibility等等 2.我们有几种方式可以隐藏一个元素： (1) CSS display的值是none。 (2) type=&quot;hidden&quot;的表单元素。 (3) 宽度和高度都显式设置为0。 (4) 一个祖先元素是隐藏的，该元素是不会在页面上显示 (5) CSS visibility的值是hidden (6) CSS opacity的指是0 3.如果元素中占据文档中一定的空间,元素被认为是可见的。可见元素的宽度或高度，是大于零。元素的visibility: hidden 或 opacity: 0被认为是可见的，因为他们仍然占用空间布局。 4.不在文档中的元素是被认为是不可见的，如果当他们被插入到文档中jQuery没有办法知道他们是否是可见的，因为元素可见性依赖于适用的样式 属性筛选选择器$(&quot;[attribute|=&apos;value&apos;]&quot;) 选择指定属性值等于给定字符串或以该文字串为前缀的元素 $(&quot;[attribute*=&apos;value&apos;]&quot;) 选择指定属性值具有包含一个给定的子符串的元素 (选择给定的属性是以包含某些值的元素) $(&quot;[attribute~=&apos;value&apos;]&quot;) 选择指定属性用空格分隔的值中包含一个给定值的元素 $(&quot;[attribute=&apos;value&apos;]&quot;) 选择指定属性是给定值的元素 $(&quot;[attribute!=&apos;value&apos;]&quot;) 选择不存在指定属性或者指定属性不等于给定值的元素 $(&quot;[attribute^=&apos;value&apos;]&quot;) 选择指定属性是以给定字符串开始的元素 $(&quot;[attribute$=&apos;value&apos;]&quot;) 选择指定属性是以给定值结尾的元素,区分大小写 $(&quot;[attribute]&quot;) 选择所有具有指定属性的元素,该元素可以是任意值 $(&quot;[attributeFilter1][attributeFilterN]&quot;) 选择匹配所有指定的属性筛选器的元素 子元素筛选选择器$(&quot;first-child&quot;) 选择所有父级元素下的第一个子元素 $(&quot;last-child&quot;) 选择所有父级元素下的最后一个子元素 $(&quot;:only-child&quot;) 若某元素是其父元素的唯一的子元素, 那么它就会被选中 $(&quot;:nth-child&quot;) 选择的他们所有父级的第n个子元素 $(&quot;:nth-last-child&quot;) 选择所有他们父元素的第n个子元素, 计数从最后一个元素开始到第一个 注意事项： (1):first只匹配一个单独的元素，但是:first-child选择器可以匹配多个：即为每个父级元素匹配第一个子元素。这相当于:nth-child(1) (2):last 只匹配一个单独的元素， :last-child选择器可以匹配多个元素：即， 为每个父级元素匹配最后一个子元素 (3)如果子元素只有一个的话，:first-child与:last-child是同一个 :only-child匹配某个元素是父元素中唯一的子元素， 就是说当前子元素是父元素中唯一的元素，则匹配 (4)jQuery实现:nth-child(n)是严格来自CSS规范，所以n值是“索引”，也就是说，从1开始计数，:nth-child(index)从1开始的，而eq(index)是从0开始的 (5)nth-child(n) 与 :nth-last-child(n) 的区别前者是从前往后计算，后者从后往前计算 表单元素选择器$(&quot;:input&quot;) 选择所有input,textarea,select和button元素 $(&quot;:text&quot;) 匹配所有文本框 $(&quot;:password&quot;) 匹配所有密码框 $(&quot;:radio&quot;) 匹配所有单选按钮 $(&quot;:checkbox&quot;) 匹配所有复选框 $(&quot;:submit&quot;) 匹配所有提交按钮 $(&quot;:image&quot;) 匹配所有图像域 $(&quot;:reset&quot;) 匹配所有重置按钮 $(&quot;:button&quot;) 匹配所有按钮 $(&quot;:file&quot;) 匹配所有文件域 注意事项： 除了input筛选选择器，几乎每个表单类别筛选器都对应一个input元素的type值。大部分表单类别筛选器可以使用属性筛选器替换。比如 $(‘:password’) == $(‘[type=password]’) 表单元素筛选选择器$(&quot;:enabled&quot;) 选取可用的表单元素 $(&quot;:disabled&quot;) 选取不可用的表单元素 $(&quot;:checked&quot;) 选取被选中的input元素 $(&quot;:selected&quot;) 选取被选中的option元素 注意事项： (1)选择器适用于复选框和单选框，对于下拉框元素, 使用 :selected 选择器 (2)在某些浏览器中选择器:checked可能会错误选取到option元素所以保险起见换用选择器input:checked确保只会选取input元素 JQ的属性与样式attr()与removeAttr()attar()方法 attr()方法用来获取和设置元素属性attr是attribute（属性）的缩写在jQuery DOM操作中会经常用到attr() attr()有4个表达式 attr(传入属性名) 获取属性的值 attr(属性名, 属性值) 设置属性的值 attr(属性名,函数值) 设置属性的函数值 attr(attributes) 给指定元素设置多个属性值, 即{属性名一: “属性值一”, 属性名二: “属性值二”,...} removeAttr()删除方法 .removeAttr( attributeName )为匹配的元素集合中的每个元素中移除一个属性(attribute) 注意: Attribute就是dom节点自带的属性Property是这个DOM元素作为对象，其附加的内容 获取Attribute就需要用attr,获取Property就需要用prop .html()与.text().html()方法 获取集合中第一个匹配元素的HTML内容或设置每一个匹配元素的html内容，具体有3种用法： .html() 不传入值,就是获取集合中第一个匹配元素的HTML内容 .html(htmlString) 设置每一个匹配元素的html内容 .html(function(index, oldhtml)) 用来返回设置HTML内容的一个函数 .text()方法得到匹配元素集合中每个元素的文本内容结合包括他们的后代或设置匹配元素集合中每个元素的文本内容为指定的文本内容。 具体有3种用法： .text() 得到匹配元素集合中每个元素的合并文本,包括他们的后代 .text(textString) 用于设置匹配元素内容的文本 .text(function(index, text)) 用来返回设置文本内容的一个函数 注意: (1).html()方法内部使用的是DOM的innerHTML属性来处理的 所以在设置与获取上需要注意的一个最重要的问题， 这个操作是针对整个HTML内容(不仅仅只是文本内容) (2).text()结果返回一个字符串,包含所有匹配元素的合并文本 两者的异同: (1).html与.text的方法操作是一样,只是在具体针对处理对象不同 (2).html处理的是元素内容,.text处理的是文本内容 (3).html只能使用在HTML文档中, .text 在XML 和 HTML 文档中都能使用 (4)如果处理的对象只有一个子文本节点, 那么html处理的结果与text是一样的 (5)火狐不支持innerText属性，用了类似的textContent属性 .text()方法综合了2个属性的支持，所以可以兼容所有浏览器 .val().val()方法 .val() 无参数，获取匹配的元素集合中第一个元素的当前值 .val(value) 设置匹配的元素集合中每个元素的值 .val(function) 一个用来返回设置值的函数 注意: (1)通过.val()处理select元素，当没有选择项被选中，它返回null (2).val()方法多用来设置表单的字段的值 (3)如果select元素有multiple（多选）属性 并且至少一个选择项被选中,.val()方法返回一个数组 这个数组包含每个选中选择项的值 .html(),.text()和.val()的差异总结1. .html(),.text(),.val() 三种方法都是用来读取选定元素的内容； 只不过.html()是用来读取元素的html内容(包括html标签) .text()用来读取元素的纯文本内容，包括其后代元素 .val()是用来读取表单元素的&quot;value&quot;值。 其中.html()和.text()方法不能使用在表单元素上, 而.val()只能使用在表单元素上； 另外.html()方法使用在多个元素上时，只读取第一个元素； .val()方法和.html()相同，如果其应用在多个元素上时， 只能读取第一个表单元素的&quot;value&quot;值 但是.text()和他们不一样，如果.text()应用在多个元素上时， 将会读取所有选中元素的文本内容。 2. .html(htmlString),.text(textString)和.val(value) 三种方法都是用来替换选中元素的内容， 如果三个方法同时运用在多个元素上时， 那么将会替换所有选中元素的内容。 .html(),.text(),.val() 都可以使用回调函数的返回值来动态的改变多个元素的内容。 addClass()与removeClass().addClass(className)方法 .addClass(className) 为每个匹配元素所要增加的一个或多个样式名 .addClass(function(index, currentClass)) 这个函数返回一个或更多用空格隔开的要增加的样式名 注意事项： .addClass()方法不会替换一个样式类名。它只是简单的添加一个样式类名到元素上 .removeClass( )方法 .removeClass([className]) 每个匹配元素移除的一个或多个用空格隔开的样式名 .removeClass( function(index, class) )一个函数，返回一个或多个将要被移除的样式名 注意事项: 如果一个样式类名作为一个参数,只有这样式类会被从匹配的元素集合中删除 。 如果没有样式名作为参数，那么所有的样式类将被移除 toggleClass()在匹配的元素集合中的每个元素上添加或删除一个或多个样式类取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类 .toggleClass(className)： 在匹配的元素集合中的每个元素上 用来切换的一个或多个(用空格隔开)样式类名 .toggleClass(className, switch )：一个布尔值，用于判断样式是否应该被添加或移除 .toggleClass([switch]) 一个用来判断样式类添加还是移除的 布尔值 .toggleClass(function(index, class, switch) [, switch]) 用来返回在匹配的元素集合中的每个元素上 用来切换的样式类名的一个函数。 接收元素的索引位置和元素旧的样式类作为参数 注意事项： (1)toggleClass是一个互斥的逻辑，也就是通过判断对应的元素上是否存在指定的Class名，如果有就删除，如果没有就增加 (2)toggleClass会保留原有的Class名后新增，通过空格隔开 .css()获取元素样式属性的计算值或者设置元素的CSS属性 获取： .css( propertyName )获取匹配元素集合中的第一个元素的样式属性的计算值 .css( propertyNames ) 传递一组数组，返回一个对象结果 设置： .css(propertyName, value )设置CSS .css( propertyName, function )可以传入一个回调函数，返回取到对应的值进行处理 .css( properties ) 可以传一个对象，同时设置多个样式 注意事项： (1)浏览器属性获取方式不同，在获取某些值的时候都jQuery采用统一的处理比如颜色采用RBG，尺寸采用px (2).css()方法支持驼峰写法与大小写混搭的写法，内部做了容错的处理 (3)当一个数只被作为值（value）的时候，jQuery会将其转换为一个字符串，并添在字符串的结尾处添加px，例如 .css(“width”,50})与.css(“width”,”50px”})一样 .css()与.addClass()设置样式的区别1.可维护性： .addClass()的本质是通过定义个class类的样式规则，给元素添加一个或多个类。css方法是通过JavaScript大量代码进行改变元素的样式通过.addClass()我们可以批量的给相同的元素设置统一规则，变动起来比较方便，可以统一修改删除。如果通过.css()方法就需要指定每一个元素是一一的修改，日后维护也要一一的修改，比较麻烦 2.灵活性： 通过.css()方式可以很容易动态的去改变一个样式的属性，不需要在去繁琐的定义个class类的规则。一般来说在不确定开始布局规则，通过动态生成的HTML代码结构中，都是通过.css()方法处理的 3.样式值： .addClass()本质只是针对class的类的增加删除，不能获取到指定样式的属性的值，.css()可以获取到指定的样式值。 4.样式的优先级：css的样式是有优先级的，当外部样式、内部样式和内联样式同一样式规则同时应用于同一个元素的时候优先级如下： 外部样式 &lt; 内部样式 &lt; 内联样式 .addClass()方法是通过增加class名的方式，那么这个样式是在外部文件或者内部样式中先定义好的，等到需要的时候在附加到元素上 通过.css()方法处理的是内联样式，直接通过元素的style属性附加到元素上的 通过.css方法设置的样式属性优先级要高于.addClass方法 5.总结： .addClass与.css方法各有利弊，一般是静态的结构，都确定了布局的规则，可以用addClass的方法，增加统一的类规则 如果是动态的HTML结构，在不确定规则，或者经常变化的情况下，一般多考虑.css()方式 元素的数据存储jQuery提供的存储接口： jQuery.data(element, key, value) 静态接口,存数据 jQuery.data(element, key) 静态接口,取数据 .data(key, value) 实例接口,存数据 .data(key) 实例接口,存数据 2个方法在使用上存取都是通一个接口，传递元素，键值数据。在jQuery的官方文档中，建议用.data()方法来代替。 删除接口： jQuery.removeData(element [, name]) .removeData([name])]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶学习(四)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F02%2F08%2FJavaScript%E8%BF%9B%E9%98%B6%E5%AD%A6%E4%B9%A0-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[js进阶学习four DOM对象补充###获取DOM对象方法 方法 说明 获得 getElementByID 通过指定id获取元素 一个 getElementsByName 通过元素名称name属性获取元素 一组 getElementsByTagName 通过标签名获取元素 一组 getAttribute()通过元素节点的属性名称获取属性的值。 elementNode.getAttribute(name) 说明:1.elementNode：元素节点。下同。2.name：要想查询的元素节点的属性名字 如: id,title setAttribute()方法增加一个指定名称和值的新属性，或者把一个现有的属性设定为指定的值。 elementNode.setAttribute(name,value) 说明：1.name: 要设置的属性名。2.value: 要设置的属性值。 注意：把指定的属性设置为指定的值如果不存在具有指定名称的属性，该方法将创建一个新属性 节点属性在文档对象模型 (DOM) 中，每个节点都是一个对象。 DOM 节点有三个重要的属性 ： nodeName 节点的名称 nodeValue 节点的值 nodeType 节点的类型 nodeName节点的名称，是只读的。 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 是属性的名称 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document nodeValue节点的值 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本自身 属性节点的 nodeValue 是属性的值 nodeType节点的类型，是只读的。以下常用的几种结点类型: 元素类型 节点类型 元素 1 属性 2 文本 3 注释 8 文档 9 访问子节点childNodes访问选定元素节点下的所有子节点的列表，返回的值可以看作是一个数组，它具有length属性 elementNode.childNodes 注意：1.如果选定的节点没有子节点， 则该属性返回不包含节点的 NodeList2.IE全系列、firefox、chrome、opera、safari兼容问题3.节点之间的空白符， 在firefox、chrome、opera、safari浏览器是文本节点 ####firstChild返回‘childNodes’数组的第一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 node.firstChild 说明：与elementNode.childNodes[0]是同样的效果。 ####lastChild返回‘childNodes’数组的最后一个子节点。如果选定的节点没有子节点，则该属性返回 NULL。 node.lastChild 说明：elementNode.childNodes[elementNode.childNodes.length-1]是同样的效果。 访问父节点parentNode获取指定节点的父节点 elementNode.parentNode 若想继续指向祖节点可以继续加上 .parenetNodeeg: elementNode.parentNode.parentNode ###访问兄弟节点 nextSibling可返回某个节点之后紧跟的节点（处于同一树层级中） nodeObject.nextSibling 说明：如果无此节点，则该属性返回 null。 ####previousSibling可返回某个节点之前紧跟的节点（处于同一树层级中） nodeObject.previousSibling 说明：如果无此节点，则该属性返回 null。 注意: 两个属性获取的是节点。Internet Explorer 会忽略节点间生成的空白文本节点(如换行符号)而其它浏览器不会忽略。 可以通过判断该节点的nodeType是否为1，来知道是否为元素节点 appendChild()在指定节点的最后一个子节点列表之后添加一个新的子节点 appendChild(newnode) 说明：newnode：指定追加的节点 insertBefore()在已有的子节点前插入一个新的子节点。 insertBefore(newnode,node); 说明：newnode: 要插入的新节点node: 指定此节点前插入节点 注意: otest.insertBefore(newnode,node);也可以改为: otest.insertBefore(newnode,otest.childNodes[0]); removeChild()从子节点列表中删除某个节点如删除成功，返回被删除的节点如失败，则返回 NULL nodeObject.removeChild(node) 说明:node：必需，指定需要删除的节点 注意: 把删除的子节点赋值给x，这个子节点不在DOM树中 但是还存在内存中，可通过 x 操作 如果要完全删除对象，给 x 赋 null 值。 replaceChild()实现子节点(对象)的替换。返回被替换对象的引用。 node.replaceChild (newnode,oldnew) 参数:newnode: 必需，用于替换 oldnew 的对象oldnew: 必需，被 newnode 替换的对象 注意:1.当 oldnode 被替换时，所有与之相关的属性内容都将被移除2.newnode 必须先被建立。 createElement()可创建元素节点,返回一个 Element 对象 document.createElement(tagName) 说明:tagName：字符串值，这个字符串用来指明创建元素的类型注意：要与appendChild() 或 insertBefore() 方法联合使用，将元素显示在页面中。 调用方式:eg:创建一个连接 var main = document.body; var at=document.createElement(&quot;a&quot;); main.appendChild(at); createTextNode()创建新的文本节点，返回新创建的 Text 节点 document.createTextNode(data) 说明：data : 字符串值，可规定此节点的文本。 调用方式:eg:创建一个div，并在里面写上”i love JaveScript” var element=document.createElement(“div”); var text=document.createTextNode(“i love JaveScript”); element.appendChild(text); document.body.appendChild(element); clientHeight&amp;&amp;clientWidth获得浏览器窗口的尺寸（浏览器的视口，不包括工具栏和滚动条）在不同浏览器都实用的 JavaScript 方案： var w= document.documentElement.clientWidth || document.body.clientWidth; var h= document.documentElement.clientHeight || document.body.clientHeight; scrollHeight&amp;&amp;scrollWidth获取网页内容高度和宽度。 var w=document.documentElement.scrollWidth || document.body.scrollWidth; var h=document.documentElement.scrollHeight || document.body.scrollHeight; offsetHeight&amp;&amp;offsetWidth获取网页内容高度和宽度(包括滚动条等边线，会随窗口的显示大小改变)offsetHeight = clientHeight + 滚动条 + 边框。 var w= document.documentElement.offsetWidth || document.body.offsetWidth; var h= document.documentElement.offsetHeight || document.body.offsetHeight; 网页卷去的距离与偏移量scrollLeft:设置或获取位于给定对象左边界 与窗口中目前可见内容的最左端之间的距离 scrollTop:设置或获取位于对象最顶端 与窗口中可见内容的最顶端之间的距离 offsetLeft:获取指定对象相对于版面 或由offsetParent属性指定的 父坐标的计算左侧位置 offsetTop:获取指定对象相对于版面 或由offsetParent属性指定的 父坐标的计算顶端位置 注意:offsetParent：布局中设置postion属性 (Relative、Absolute、fixed)的父容器 从最近的父节点开始，一层层向上找 直到HTML的body 参考:http://blog.csdn.net/xiebaochun/article/details/38382169]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶(三)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F02%2F08%2FJavaScript%E8%BF%9B%E9%98%B6-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[javascript进阶学习总结三 浏览器对象(BOM)window对象java计时器在JavaScript中，我们可以在设定的时间间隔之后来执行代码而不是在函数被调用后立即执行。 计时器类型：一次性计时器：仅在指定的延迟时间之后触发一次。间隔性触发计时器：每隔一定的时间间隔就触发一次。 setTimeout():指定的延迟时间之后来执行代码。 clearTimeout():取消setTimeout的设置。 setInterval():每隔指定的时间执行代码。 clearInterval():取消setInterval()设置。 setInterval()在执行时,从载入页面后每隔指定的时间执行代码。 setInterval(代码,交互时间); 说明：1.代码：要调用的函数或要执行的代码串 2.交互时间：周期性执行或调用表达式之间的时间间隔 以毫秒计（1s=1000ms） 返回值:一个可以传递给 clearInterval()从而取消对”代码”的周期性执行的值 调用方式(假设有一个clock()函数): setInterval(&quot;clock()&quot;,1000) 或 setInterval(clock,1000) clearInterval()clearInterval() 方法可取消由 setInterval() 设置的交互时间 clearInterval(id_of_setInterval) 说明: id_of_setInterval：由 setInterval() 返回的 ID 值。 计时器setTimeout()setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次 setTimeout(代码,延迟时间); 说明：1.代码: 要调用的函数或要执行的代码串 2.延时时间：在执行代码前需等待的时间， 以毫秒为单位（1s=1000ms)。 取消计时器clearTimeout()setTimeout()和clearTimeout()一起使用，停止计时器 clearTimeout(id_of_setTimeout) 参数说明:id_of_setTimeout：由 setTimeout() 返回的 ID 值 History 对象history对象记录了用户曾经浏览过的页面(URL)，并可以实现浏览器前进与后退相似导航的功能 window.history.[属性|方法] History对象属性: length 返回浏览器历史列表中的URL数量 History对象方法 back() 加载history列表中的前一个URL forward() 加载history列表中的后一个URL go() 加载history列表中的某个具体的页面 go(0) 当前页面 go(1) 相当forward() go(-1) 相等back() go(n) 访问history的url列表中相对位置的URL Location对象location用于获取或设置窗体的URL，并且可以用于解析URL location.[属性|方法] location对象属性: hash 设置或返回从井号（#）开始的URL（锚） host 设置或返回主机名和当前URL的端口号 hostname 设置或返回当前URL的主机名 href 设置或返回当前URL。 pathname 设置或返回当前URL的路径部分 port 设置或返回当前URL的协议。 search 设置或返回从问号（？）开始的URL(查询部分) location对象方法: assign() 加载新的文档 reload() 重新加载当前文档 replace() 用新的文档替换当前文档 Navigator对象Navigator 对象包含有关浏览器的信息通常用于检测浏览器与操作系统的版本 Navigator.属性 Navigator对象属性: appCodeName 浏览器代码名的字符串表示 appName 返回浏览器的名称 appVersiion 返回浏览器的平台和版本信息 platform 返回运行浏览器的操作系统平台 userAgent 返回由客户机发送服务器的user-agent头部的值 screen对象screen对象用于获取用户的屏幕信息 window.screen.属性 screen对象属性: availHeight：窗口可以使用的屏幕高度，单位像素； availWidth：窗口可以使用的屏幕宽度，单位像素； colorDepth：用户浏览器表示的颜色位数， 通常为32位(每像素的位数) pixelDepth：用户浏览器表示的颜色位数， 通常为32位(每像素的位数) (IE不支持此属性) height：屏幕的高度，单位像素； width：屏幕的宽度，单位像素；]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶(二)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F02%2F05%2FJavaScript%E8%BF%9B%E9%98%B6-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[js进阶学习总结two js内置对象Date 日期对象日期对象可以储存任意一个日期，并且可以精确到毫秒数（1/1000 秒）。定义一个时间对象 : var Udate=new Date(); 访问方法语法：“&lt;日期对象&gt;.&lt;方法&gt;”Date对象中处理时间和日期的常用方法： get/setDate() 返回/设置日期 get/setFullYear() 返回/设置年份，用四位数表示 get/setYear() 返回/设置年份 get/setHours() 返回/设置小时 24小时 get/setMouth() 返回/设置月份 0-11月 所以要加一 get/setMinutes() 返回/设置分钟 get/setTime() 返回/设置时间，毫秒为单位，计算从 1970 年 1 月 1 日零时到日期对象所指的日期的毫秒数。 可以在设置时间上推迟时间:eg:时间推迟 1 小时就是: “x.setTime(x.getTime() + 60 60 1000);” 获取星期的方法:getDay() 返回星期，返回的是0-6的数字，0 表示星期天。如果要返回相对应“星期”，通过数组完成，代码如下: &lt;script type=&quot;text/javascript&quot;&gt; var mydate=new Date(); var weekday=[&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;, &quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;]; document.write(&quot;今天是：&quot;+ weekday[mydate.getDay()]); &lt;/script&gt; 字符串对象定义字符串的方法就是直接赋值。eg： var mystr = &quot;Hello World&quot; 访问字符串对象的属性length: stringObject.length; 返回该字符串的长度。 访问字符串对象的方法： stringObject.方法 toUpperCase() 将字符串所有小写字母转换为大写 toLowerCase() 将字符串所有大写字母转换为小写 charAt(index)返回指定位置的字符(index为字符下标,必填)返回的字符是长度为 1 的字符串。 注意： 1.字符串中第一个字符的下标是0。 最后一个字符的下标为字符串长度减一(string.length-1) 2.如果参数index不在 0 与string.length-1之间， 该方法将返回一个空字符串 3.空格也算一个字符 indexOf(substring, startpos)返回某个指定的字符串值在字符串中首次出现的位置.substring(必填), startpos(可选参数) 说明： 1.该方法将从头到尾地检索字符串stringObject, 看它是否含有子串substring 2.可选参数，从stringObject的startpos位置开始查找substring，如果没有此参数将从stringObject的开始位置查找。 3.如果找到一个 substring，则返回substring的第一次出现的位置stringObject 中的字符位置是从 0 开始的 若要检索的字符串值没有出现，则返回-1 字符串分割split(separator,limit)将字符串分割为字符串数组，并返回此数组。 sparator为必填参数，以该参数为标志分割数组 limit为可选参数，分割次数，设置后，返回的字符串不会超过分割次数,省略后将返回所有分割的字符串 注意：如果把空字符串(“”)作为separator,那么stringObject中的每个字符之间都会被分割。 substring(startPos,stopPos)提取字符串中介于两个指定下标之间的字符 startPos为必填参数，一个非负整数，开始位置 stopPos为可填参数，一个非负整数，结束位置,省略后默认为字符串末尾 注意： 1.返回的内容是从start开始(包含start位置的字符)到stop-1 处的所有字符，其长度为 stop 减start。 2.如果参数 start 与 stop 相等，那么该方法返回的就是一个空串(即长度为 0 的字符串) 3.如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。 substr(startPos,length)从字符串中提取从 startPos位置开始的指定数目的字符串。 startPos为必填参数,开始位置.必须是数值 length为可填参数,提取的字符串长度,省略则返回从startPos到字符串对象的结尾的字符 注意： 1.如果参数startPos是负数，从字符串的尾部开始算起的位置。即:-1 指字符串中最后一个字符，-2指倒数第二个字符,以此类推 2.如果startPos为负数且绝对值大于字符串长度，startPos为0。 Math对象Math对象，提供对数据的数学计算。Math对象是一个固有的对象，无需创建它，直接把 Math 作为对象使用就可以调用其所有属性和方法eg： var mypi=Math.PI; //获取π值调用方式: Math.方法常用方法: ceil(X) 对一个数进行向上取整，X必填,为一个数值。下同 floor(X) 对一个数进行向下取整。 round(X) 把一个数字四舍五入为最接近的整数。 random() 返回介于 0 ~ 1（大于或等于 0 但小于 1 ) 之间的一个随机数。 数组对象(补充)数组方法: 调用方式: arrayObject.方法 concat() 连接两个或更多的数组，并返回结果 join() 把数组的所有元素放入一个字符串 元素通过指定的分隔符进行分隔 pop() 删除并返回数组的最后一个元素 push() 向数组的未尾添加一个或多个元素 并返回新的长度 reverse() 颠倒数组中的元素顺序 shift() 删除并返回数组的第一个元素 slice() 从某个已有的数组返回选定的元素 sort() 对数组的元素进行排序 splice() 删除元素，并向数组添加新元素 toSource() 返回该对象的源代码 toString() 把数组转换为字符串，并返回结果 部分方法详解: concat(array1,array2,…,arrayN)连接两个或多个数组。返回一个新数组(副本)，不改变原来的数组。array1为要连接的第一个数组，以此类推 join(separator)把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。sperator为可选参数，指定的分隔符，省略默认为 逗号 注意：返回的字符串中，是把数组中的各个元素串起来，用&lt;分隔符&gt;置于元素与元素之间。这个方法不影响数组原本的内容。 reverse()用于颠倒数组中元素的顺序 该方法会改变原来的数组，而不会创建新的数组。 slice(start, end)从已有的数组中返回选定的元素。 返回一个新的数组，包含从 start 到 end(不包括end)的arrayObject中的元素该方法并不会修改数组，而是返回一个子数组。 start 为必填参数(数值)，开始选取的位置，若为负数则从数组末尾开始往回数 end 为可选参数，结束的位置，省略默认从start到数组末尾 String.slice() 与 Array.slice() 相似。 sort(sortMethod)使数组中的元素按照一定的顺序排列。 sortMethod为可填参数，规定排序顺序，必须为函数说明： 1.如果不指定&lt;方法函数&gt;，则按unicode码顺序排列。2.如果指定&lt;方法函数&gt;，则按&lt;方法函数&gt;所指定的排序方法排序。 注意: 该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若返回值&lt;=-1，则表示 A 在排序后的序列中出现在 B 之前。 若返回值&gt;-1 &amp;&amp; =1，则表示 A 在排序后的序列中出现在 B 之后。 升序： function sortNum(a,b) { return a - b; //如降序，把“a - b”该成“b - a” }]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript进阶(一)]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F02%2F02%2FJavaScript%E8%BF%9B%E9%98%B6-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[JavaScript进阶学习总结（一） js基础语法补充操作符js中拥有:算术操作符(+、-、 * , /、–、++等)，比较操作符(&lt;、&gt;、&gt;=、&lt;=、==、!=)，逻辑操作符(&amp;&amp;、||、！)。功能与C语言一致。 算术运算符主要用来完成类似加减乘除，自增自减的工作，在JS中，“+”不只代表加法，还可以连接两个字符串 比较操作符主要用于两个操作数的比较，成立返回true，否则返回false 逻辑运算符主要用于条件判断，成立返回true，否则返回false 操作符之间的优先级（高到低）:算术操作符 → 比较操作符 → 逻辑操作符 → “=”赋值符号 定义数组var 变量名=new Array(); js的数组元素下标也是从0开始的,元素成员也是 变量名[num] 来表示，不过要注意的是： 1.创建的新数组是空数组，没有值，如输出，则显示undefined。 2.虽然创建数组时，指定了长度，但实际上数组都是变长的， 也就是说即使指定了长度为8，仍然可以将元素存储在规定长度以外 数组长度: myarray.length; //获得数组myarray的长度 二维数组的定义有两种方式: 1. var myarr=new Array(); //先声明一维 for(var i=0;i&lt;2;i++) //一维长度为2 { myarr[i]=new Array(); //再声明二维 for(var j=0;j&lt;3;j++) //二维长度为3 { myarr[i][j]=i+j; //赋值，每个数组元素的值为i+j } } 2. var myarr = [[0 , 1 , 2 ],[1 , 2 , 3]] //myarr[2][3] 流程控制js中有if语句、if-else语句、if-else嵌套语句while语句、do-while语句（不用在最后加 ; ）for语句、switch语句、continue、break语句。 它们的功能语法与C语言的一致。 if-else嵌套:if(条件1) { 条件1成立时执行的代码} else if(条件2) { 条件2成立时执行的代码} ... else if(条件n) { 条件n成立时执行的代码} else { 条件1、2至n不成立时执行的代码} while循环语句：while(判断条件) { 循环语句 } switch语句:switch(表达式) { case值1: 执行代码块 1 break; case值2: 执行代码块 2 break; ... case值n: 执行代码块 n break; default: 与 case值1、...case值n 不同时执行的代码 } for循环语句：for(初始化变量;循环条件;循环迭代) { 循环语句 } do-while语句do { 循环语句 } while(判断条件) 事件响应在网页中，如使用事件，就在该元素中设置事件属性。eg: &lt; input .... 事件=&quot;函数名()&quot; /&gt; 鼠标单击事件(onclick)onclick是鼠标单击事件，当在网页上单击鼠标时，就会发生该事件。同时onclick事件调用的程序块就会被执行，通常与按钮一起使用。 鼠标经过事件（onmouseover）鼠标经过事件，当鼠标移到一个对象上时，该对象就触发onmouseover事件，并执行onmouseover事件调用的程序 鼠标移开事件（onmouseout）鼠标移开事件，当鼠标移开当前对象时，执行onmouseout调用的程序 光标聚焦事件（onfocus）当网页中的对象获得聚点时，执行onfocus调用的程序就会被执行 失焦事件（onblur）onblur事件与onfocus是相对事件，当光标离开当前获得聚焦对象的时候，触发onblur事件，同时执行被调用的程序。 内容选中事件（onselect）选中事件，当文本框或者文本域中的文字被选中时，触发onselect事件，同时调用的程序就会被执行。 文本框内容改变事件（onchange）通过改变文本框的内容来触发onchange事件，同时执行被调用的程序 加载事件（onload）事件会在页面加载完成后，立即发生，同时执行被调用的程序。注意：1. 加载页面时，触发onload事件，事件写在&lt; body &gt;标签内 卸载事件（onunload）当用户退出页面时（页面关闭、页面刷新等），触发onUnload事件，同时执行被调用的程序。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript入门]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F02%2F01%2FJavaScript%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[JavaScript入门(基础学习总结) 基础语法基本规则一行的结束就被认定为语句的结束，通常在结尾加上一个分号”;”来表示语句的结束。 javascript作为一种脚本语言可以放在html页面中任何位置。但浏览器解释html时是按先后顺序的，所以前面的script就先被执行。比如进行页面显示初始化的js必须放在head里面,因为初始化都要求提前进行(如给页面body设置css等);而如果是通过事件调用执行的function那么对位置没什么要求的。 js文件引用&lt;script src=&quot;文件名&quot;&gt;&lt;/script&gt; js注释// 注释一行 /**/ 注释多行 定义变量var 变量名; 注意: 1. 变量名必须以下划线&apos;_&apos;、英文字母或美元符号&apos;$&apos;开始. 2. 变量名可以使用任意多个英文字母，数字，下划线，或者美元符号组成 3. 变量名不能使用JavaScript关键词和JavaScript保留字 可以给变量赋值数字，字母，字符串，true或false. 附： javascript保留字： abstract、enum、int、short、boolean、export、interface、 static、byte、extends、long、super、char、final、native、 synchronized、class、float、package、throws、const、goto、 private、tranisientdebugger、implements、protected、volatile、 double、import、public javascript关键字： break、else、new、var、case、finally、return、void、catch、 for、switch、while、default、if、throw、delete、in、 try、do、instanceof、typeof 定义函数function 函数名(形参) { 函数代码; return 返回值; } 形参和返回语句可有可无，返回值可以是数字，字母，字符串，ture/false返回值可以用变量取接。 调用函数： 函数名(参数); 条件语句if(条件) { 条件成立时执行的代码 } else { 条件不成立时执行的代码 } 输出内容(document.write())第一种:输出内容用””括起，直接输出””号内的内容。 &lt;script type=&quot;text/javascript&quot;&gt; document.write(&quot;I love JavaScript！&quot;); //内容用&quot;&quot;括起来，&quot;&quot;里的内容直接输出。 &lt;/script&gt; 第二种:通过变量，输出内容 &lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello world!&quot;; document.write(mystr); //直接写变量名，输出变量存储的内容。 &lt;/script&gt; 第三种:输出多项内容，内容之间用+号连接。 &lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello&quot;; document.write(mystr+&quot;I love JavaScript&quot;); //多项内容之间用+号连接 &lt;/script&gt; 第四种:输出HTML标签，并起作用，标签使用””括起来。 &lt;script type=&quot;text/javascript&quot;&gt; var mystr=&quot;hello&quot;; document.write(mystr+&quot;&lt;br&gt;&quot;);//输出hello后，输出一个换行符 document.write(&quot;JavaScript&quot;); &lt;/script&gt; 输出时，加上“white-space:pre”(空白会被浏览器保留)样式， 可以输出空格。 常用互动语法js-警告alert(字符串); alert 弹出消息对话框(包含一个确定按钮)。 js-确定(confirm消息对话框)confirm(str); str:在消息对话框中要显示的文本 返回值: 按下“确定”，返回true 按下“取消”，返回false 返回值用于判断语句。 js-提问(prompt)prompt(str1,str2); str1:要显示在消息对话框中的文本，不可修改 str2:文本框的内容，可以修改 返回值： 点击确定，文本框中的内容作为返回值 点击取消，返回null js-打开新窗口(window.open)window.open([URl],[窗口名称],[参数字符串]) URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。 窗口名称：可选参数，被打开窗口的名称。 注意： 1.该名称由字母、数字和下划线字符组成。 2.&quot;_top&quot;、&quot;_blank&quot;、&quot;_self&quot;具有特殊意义的名称。 _blank：在新窗口显示目标网页 _self：在当前窗口显示目标网页 _top：框架网页中在上部窗口中显示目标网页 3.相同 name 的窗口只能创建一个， 要想创建多个窗口则 name 不能相同。 4.name 不能包含有空格。 参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。 参数 值 说明 top Number 窗口顶部离屏幕顶部的像素数 left Number 窗口左侧离屏幕左侧的像素数 width Number 窗口的高度 height Number 窗口的宽度 menubar yes/no 窗口有没有菜单 toolbar yes/no 窗口有没有工具条 scrollbars yes/no 窗口有没有滚动条 status yes/no 窗口有没有状态栏 js-关闭窗口(window.close)window.close;//关闭本窗口 或 &lt;窗口对象&gt;.close();//关闭指定窗口 DOM文档对象模型DOM（Document Object Model）定义访问和处理HTML文档的标准方法。DOM 将HTML文档呈现为带有元素、属性和文本的树结构(节点树) 元素节点：&lt; html &gt; &lt; body &gt; &lt; p &gt; 等标签 文本节点：向用户展示的内容,如&lt; li &gt;间的文本 属性节点: 元素属性，如&lt; a &gt;标签的链接属性 herf=”” 获取iddocument.getElementById(&quot;id&quot;) 以变量接取，var i=document.getElementById(“id”); innerHTML属性innerHTML(区分大小写)属性用于获取或替换HTML元素的内容 object.innerHTML//object为获取的对象，下同 eg: &lt; p id=&quot;con&quot;&gt;xxxxxx&lt; /p &gt; var i=document.getElementById(&quot;con&quot;); i.innerHTML=&quot;hello world&quot; //修改p中的内容为&quot;hello world&quot; 改变HTML样式object.style.display=&quot;value&quot;; value: none 此元素不会被显示(隐藏) block 此元素将显示为块级元素(显示) 控制类名(className属性)object.className=classname; 作用： 1.获取元素的class属性 2.为网页内的某个元素指定一个css样式来改变外观 取消获取的样式1. object.removeAttribute(&quot;style&quot;); 2. object.style=null; 3.object.style=&quot;&quot;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime使用技巧]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F01%2F28%2Fsublime%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前端工具sublime的使用技巧，从慕课中总结而来 一些插件及与其相关的快捷键的使用：安装Packet：菜单栏View-&gt;Show Console-&gt;粘贴text2或text3的Packet配置信息-&gt;重启软件-&gt;Ct+N（新建文档）-&gt;Ct+Sh+P-&gt;输入pci-&gt;查找要安装的插件 Emmet插件：安装好Emmet插件后： ！+Ct+E:迅速生成html的基础元素 Ct+P:查找时加 #元素名；找到后，若要在该行下新加一行，可按 Ct+Enter 上一行 Ct+Sh+Enter ul&gt;.item$*10 ,再按Ct+E， 则一次性生成10个&lt;li class=&quot;item(1/2/3/../10)&quot;&gt;&lt;/li&gt; 即 父元素&gt; .（表示有class标签或用 # 表示有id值） 类名（id名）$*（子元素出现次数），再Ct+E 在文本中写 h2{this is good} 再按Ct+E, 则生成 &lt;h2&gt;this is good&lt;/h2&gt; Ct+ 键盘上含 } 的键：文本缩进 Ct+Sh+V：粘贴时保持复制时的格式，如缩进等 insert callback插件Alt+C：删除多于的符号 advanNewCtrl+Shift+P打开命令模式，输入”pci”（Package Control:Install Package），在提示框输入”adva”，选”AdvancedNewFile”进行安装。 安装完成后使用&quot;Ctrl+Alt+N&quot; 选在屏幕下方出现的输入框中输入”test.html”，创建了一个html文件； 输入框中输入”public/css/test.css”，则在public目录下的css中创建了一个test.css文件； 输入框中输入”public/css/sass/test.sass”，则在public目录下的css中创建了一个sass文件夹并在其中创建了一个test.sass文件。 httpRequesterCtrl+Shift+P打开命令模式， 输入&quot;pci&quot;（Package Control:Install Package）， 在提示框输入&quot;http&quot;，选&quot;Http Requester&quot;进行安装。 安装完成后要使用注解的方式来标记函数需要测试的路由地址 在Sublime内部，做服务器响应的测试Get请求 /* GET users listing. */ // localhost:3000/users/ router.get(&apos;/&apos;, function(req, res) { res.send(&apos;respond with a resource&apos;); }); 注释需要测试的路由地址”// localhost:3000/users/“（localhost为路由地址，3000为端口号）选中”localhost:3000/users/“，使用快捷键”Alt+Ctrl+R”，出现新的页面显示服务器的响应，“200 OK”表示服务器响应正确。 get请求比较容易测试，可以在浏览器中输入地址；post请求比较难以测试以前测试post请求需要完成一个表单（用html语言写），然后模拟提交，这样不利于开发 不需要前端form表单的情况下来模拟form提交，先完成post请求在Sublime内部，做服务器响应的测试Post请求 /* POST localhost:3000/users/ Content-type: application/x-www-form-urlencoded POST_BODY: variable1=avalue&amp;variable2=1234&amp;variable3=anothervalue */ router.post(&apos;/&apos;, function(req, res) { res.send(req.body);}); （POST：访问地址是一个post请求， &quot;localhost:3000/users/&quot;是访问的地址， &quot;Content-type...anothervalue&quot;指定是以form表单形式提交） 选中&quot;/* */&quot;内的注释， 使用快捷键&quot;Alt+Ctrl+R&quot;，出现新的页面显示服务器的响应， &quot;200 OK&quot;表示服务器响应正确 netauke Snipsidebar enhancement右击对应文档，有直接浏览该页的选项 docblockr用于简化注释拼写 /** +Tab键 ：可有函数的注释格式 /** 或 /* + 回车键：其余注释符自动补充 输入/*按回车，补充行注释。 输入/**按回车，补充多行注释。 在写好的函数上方输入/**按tab键，自动补充函数说明格式。 Ctrl+/: 行注释; Ctrl+Shift+/: 块注释. sublimelinter-jshlint用于语法、风格的检验 安装jsnode插件 -&gt; 安装sublimelinter-jshlint插件 -&gt;运行cmd， 输入 npm install -g jshint -&gt;最后到sulimt软件里检验 补充9.html代码对齐插件html beautiful； 安装后快捷键ctr + alt + shift + f SideBarEnhancementsctrl+shift+p —&gt;Install Package —&gt;找到SideBarEnhancements安装SideBarEnhancements 配置预览快捷键 Preferences —&gt; Key Bindings - User 将以下代码复制到数组中。 // chrome { &quot;keys&quot;: [&quot;f2&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: { &quot;paths&quot;: [], &quot;application&quot;: &quot;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; } }, // firefox { &quot;keys&quot;: [&quot;f3&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: { &quot;paths&quot;: [], &quot;application&quot;: &quot;D:/Program Files (x86)/Mozilla Firefox/firefox.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; } }, // ie { &quot;keys&quot;: [&quot;f4&quot;], &quot;command&quot;: &quot;side_bar_files_open_with&quot;, &quot;args&quot;: { &quot;paths&quot;: [], &quot;application&quot;: &quot;C:/Program Files/Internet Explorer/iexplore.exe&quot;, &quot;extensions&quot;:&quot;.*&quot; } } 上面的代码中有两处需要注意的地方，一个是keys表示快捷键，即f2可以启动chrome进行预览。另一个是application，表示浏览器所在的安装路径，只有路径配置正确，才能够正常调用浏览器 nettus fetch插件ctrl+shift+p---&gt;输入nettus fetch回车 ---&gt;ctrl_shift+p---&gt;输入fetch manage来管理配置文件 使用fetch来下载jquery步骤： ctrl+alt+n 在某个目录下创建一个jQuery文件---&gt; 在该文件中输入ctrl+shift+p---&gt; 输入fetch file回车---&gt;jquery回车下载。 在fetch配置文件中来增加新的类库（如：underscore.js）：步骤如下： 在该文件中添加&quot;underscore&quot;: &quot;http://github.com /jashkenas/underscore/blob/master/underscore.min.js&quot; 和前一个参数以&quot;逗号&quot;来分隔。 ctrl+alt+n 在某个目录下创建一个underscore文件---&gt; 在该文件中输入ctrl+shift+p---&gt; 输入fetch file回车---&gt;jquery回车下载。 到github下载underscore.js文件github上的underscore文件地址： https://raw.githubusercontent.com/ jashkenas/underscore/master/underscore-min.js 快捷键的使用1、Ctrl+H：查找替换2、Ctrl+D：选择游标所在单词，连续Ctrl+D实现多行选择（选择与第一次选择相同的单词）3、Ctrl+K Ctrl+D：跳过当前选择，选择下一个4、Ctrl+shift+D：复制游标所在行5、Ctrl+F3：选择所以与游标所在单词相同的单词6、全选：先Ctrl+A全选然后Ctrl+shift+L产生游标7、按住shift，右键，拖动，产生多行游标8、Ctrl+P 的作用是：搜索项目中的文件 go to anything9、Ctrl+Shift+P 快捷键的作用是：打开命令模式10、Ctrl+Shift+K 的快捷键是：删除整行11、ctrl+shift+v 保持缩进粘贴12、Ctrl+] 增加缩进 [ 减小缩进。13、Alt+. 闭合标签14、Alt+&gt; 闭合标签15、Ctrl+? 注释一行]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fsollylee.github.io%2F2018%2F01%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
